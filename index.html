<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlipaClip</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none;
            overflow: hidden;
            background-color: #f3f4f6;
        }

        .tab-indicator {
            transition: all 0.3s ease;
        }

        .hidden {
            display: none;
        }

        .modal {
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 1rem;
            width: 90%;
            max-width: 500px;
        }

        .tool-button {
            background-color: #f3f4f6;
            border-radius: 9999px;
            padding: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .tool-button.active {
            background-color: #ef4444;
            color: white;
            box-shadow: 0 10px 15px -3px rgba(239, 68, 68, 0.5), 0 4px 6px -2px rgba(239, 68, 68, 0.5);
            transform: scale(1.1);
        }

        .canvas-container {
            position: relative;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.06);
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 90vw;
            max-width: 600px;
            aspect-ratio: 16 / 9;
            height: auto;
        }

        #drawingCanvas, #onionSkinCanvas, #selectionCanvas {
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            border: 1px solid #333;
            background-color: white;
            touch-action: none;
            width: calc(100% - 8px);
            height: calc(100% - 8px);
        }

        #drawingCanvas {
            z-index: 2;
        }

        #onionSkinCanvas {
            opacity: 0.35;
            pointer-events: none;
            border: none;
            z-index: 1;
        }
        
        #selectionCanvas {
            pointer-events: none;
            border: none;
            z-index: 3;
        }

        .frame-preview {
            width: 3.5rem;
            height: 3.5rem;
            min-width: 3.5rem;
            border: 2px solid #333;
            border-radius: 0.5rem;
            cursor: pointer;
            position: relative;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .frame-preview.active {
            border-color: #ef4444;
            box-shadow: 0 0 0 2px #ef4444;
        }

        .frame-preview .frame-number {
            position: absolute;
            top: 0;
            right: 0;
            background-color: #ef4444;
            color: white;
            font-size: 0.75rem;
            font-weight: bold;
            padding: 0.125rem 0.375rem;
            border-radius: 9999px;
        }

        .controls-bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #fff;
            box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 50;
            border-top-left-radius: 1.5rem;
            border-top-right-radius: 1.5rem;
            padding: 1rem;
        }

        .timeline-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
        }
        
        .layer-panel {
            position: fixed;
            bottom: -100%;
            left: 0;
            width: 100%;
            max-height: 50%;
            background-color: white;
            border-top-left-radius: 1.5rem;
            border-top-right-radius: 1.5rem;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);
            z-index: 60;
            transition: bottom 0.3s ease-in-out;
            padding: 1rem;
            overflow-y: auto;
        }

        .layer-panel.active {
            bottom: 0;
        }

        .layer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background-color: #f9fafb;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            cursor: grab;
            transition: transform 0.2s, background-color 0.2s;
            position: relative;
            overflow: hidden;
        }

        .layer-item .drag-handle {
            cursor: grab;
        }

        .layer-item .layer-actions {
            display: flex;
            align-items: center;
            background-color: #ef4444;
            color: white;
            position: absolute;
            right: -100%;
            top: 0;
            bottom: 0;
            padding: 0 1rem;
            transition: right 0.2s ease-in-out;
        }

        .layer-item.swiped .layer-actions {
            right: 0;
        }

        .frame-context-menu {
            position: absolute;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            min-width: 120px;
            padding: 8px 0;
            top: -80px;
            left: 50%;
            transform: translateX(-50%);
        }

        .frame-context-menu::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: white;
        }

        .frame-context-menu button {
            width: 100%;
            text-align: left;
            padding: 8px 16px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .frame-context-menu button:hover {
            background-color: #f3f4f6;
        }

        .frame-context-menu button.delete:hover {
            background-color: #fee2e2;
            color: #dc2626;
        }

        .frame-preview.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .frame-preview.drag-over {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px #3b82f6;
        }

        /* Sidebar styles */
        #toolSidebar {
            background: linear-gradient(180deg, #1f2937 0%, #111827 100%);
        }

        #toolSidebar.open {
            transform: translateX(0);
        }

        .sidebar-tool {
            width: 48px;
            height: 48px;
            background-color: rgba(75, 85, 99, 0.5);
            color: #d1d5db;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sidebar-tool:hover {
            background-color: rgba(99, 102, 241, 0.3);
            color: white;
            transform: scale(1.05);
        }

        .sidebar-tool.active {
            background-color: #6366f1;
            color: white;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        #brushSize {
            width: 60px;
        }

        #brushSize::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: #6366f1;
            border-radius: 50%;
            cursor: pointer;
        }

        #brushSize::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #6366f1;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .color-preset {
            transition: transform 0.2s;
        }

        .color-preset:hover {
            transform: scale(1.1);
        }

        .color-preset.active {
            transform: scale(1.2);
            box-shadow: 0 0 0 2px white;
        }

        @media (min-width: 768px) {
            #drawingArea.sidebar-open {
                margin-left: 80px;
            }
        }
        
        @media (max-width: 767px) {
            #toolSidebar {
                width: 70px;
            }
            
            #drawingArea.sidebar-open {
                margin-left: 70px;
            }
        }
    </style>
</head>
<body>

    <!-- Modal para crear nuevo proyecto -->
    <div id="newProjectModal" class="fixed inset-0 hidden modal">
        <div class="modal-content text-center">
            <h2 class="text-2xl font-bold mb-4">¡Nuevo proyecto!</h2>
            <p class="text-gray-600 mb-6">¿Quieres crear un nuevo proyecto de animación?</p>
            <div class="flex justify-center space-x-4">
                <button id="cancelButton" class="px-6 py-2 bg-gray-300 text-gray-800 rounded-full font-semibold">Cancelar</button>
                <button id="createButton" class="px-6 py-2 bg-red-500 text-white rounded-full font-semibold">Crear</button>
            </div>
        </div>
    </div>

    <!-- Pantalla de inicio -->
    <div id="homeScreen" class="w-full h-full flex flex-col">
        <!-- Navbar Superior -->
        <div class="fixed top-0 left-0 w-full bg-white shadow-md z-50 rounded-b-xl">
            <div class="flex items-center justify-between p-4">
                <div class="flex items-center space-x-4">
                    <i class="fas fa-bars text-xl text-gray-600 cursor-pointer"></i>
                </div>
                <div class="flex-grow flex justify-center">
                    <span class="text-2xl font-bold text-gray-800 tracking-wider">FlipaClip</span>
                </div>
                <div class="flex items-center space-x-4">
                    <i class="fas fa-search text-xl text-gray-600 cursor-pointer"></i>
                    <i class="fas fa-ellipsis-v text-xl text-gray-600 cursor-pointer"></i>
                </div>
            </div>
            <!-- Pestañas -->
            <div class="flex justify-around text-gray-600 font-semibold text-lg border-b border-gray-200">
                <div id="proyectosTab" class="flex-1 text-center py-3 cursor-pointer relative">
                    Proyectos
                    <div class="tab-indicator absolute bottom-0 left-1/2 -translate-x-1/2 w-0 h-1 bg-red-500 rounded-t"></div>
                </div>
                <div id="peliculasTab" class="flex-1 text-center py-3 cursor-pointer relative">
                    Películas
                    <div class="tab-indicator absolute bottom-0 left-1/2 -translate-x-1/2 w-0 h-1 bg-red-500 rounded-t"></div>
                </div>
            </div>
        </div>

        <!-- Contenido de la página -->
        <main class="flex-grow p-4 mt-36 w-full max-w-2xl overflow-y-auto pb-24">
            <div id="proyectosContent" class="grid grid-cols-2 gap-4">
                <!-- Proyectos se renderizarán aquí -->
            </div>
            <div id="peliculasContent" class="grid grid-cols-2 gap-4 hidden">
                <!-- Contenido de Películas -->
                <p class="col-span-2 text-center text-gray-500 mt-10">¡Aún no tienes películas! Crea un proyecto primero.</p>
            </div>
        </main>

        <!-- Barra de navegación inferior -->
        <div class="fixed bottom-0 left-0 w-full bg-white shadow-lg rounded-t-2xl z-50">
            <div class="flex justify-around items-center h-16">
                <div class="flex flex-col items-center text-red-500 cursor-pointer">
                    <i class="fas fa-home text-xl"></i>
                    <span class="text-xs mt-1">INICIO</span>
                </div>
                <div class="flex flex-col items-center text-gray-400 cursor-pointer">
                    <i class="fas fa-rocket text-xl"></i>
                    <span class="text-xs mt-1">DESCUBRE</span>
                </div>
                <div class="relative -top-6">
                    <button id="addProjectBtn" class="bg-red-500 text-white p-4 rounded-full shadow-lg transition transform active:scale-95">
                        <i class="fas fa-plus text-2xl"></i>
                    </button>
                </div>
                <div class="flex flex-col items-center text-gray-400 cursor-pointer">
                    <i class="fas fa-film text-xl"></i>
                    <span class="text-xs mt-1">MIRAR</span>
                </div>
                <div class="flex flex-col items-center text-gray-400 cursor-pointer">
                    <i class="fas fa-search text-xl"></i>
                    <span class="text-xs mt-1">BUSCAR</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Pantalla de diseño de FlipaClip -->
    <div id="designScreen" class="hidden w-full h-full flex flex-col items-center">
        <!-- Navbar Superior de diseño -->
        <div class="fixed top-0 left-0 w-full bg-white shadow-md z-50 rounded-b-xl">
            <div class="flex justify-between items-center p-4">
                <i id="closeBtn" class="fas fa-times text-2xl text-gray-600 cursor-pointer"></i>
                <div class="flex-grow text-center text-gray-500 font-semibold">OCULTAR</div>
                <div class="flex items-center space-x-4">
                    <i class="fas fa-expand text-gray-600 cursor-pointer"></i>
                    <button id="deleteSelectionBtn" class="hidden tool-button bg-red-500 text-white rounded-full p-2"><i class="fas fa-trash-alt"></i></button>
                    <i class="fas fa-upload text-gray-600 cursor-pointer"></i>
                    <i class="fas fa-ellipsis-v text-gray-600 cursor-pointer"></i>
                </div>
            </div>
            <!-- Barra de herramientas simplificada -->
            <div class="flex justify-around p-4 relative">
                <button id="toggleToolbarBtn" class="tool-button">
                    <i class="fas fa-toolbox text-xl"></i>
                </button>
                <button id="playBtn" class="bg-gray-200 text-gray-700 px-4 py-2 rounded-full font-semibold">
                    <i class="fas fa-play"></i> Reproducir
                </button>
                <button id="onionSkinBtn" class="bg-gray-200 text-gray-700 p-2 rounded-full">
                    <i class="fas fa-layer-group"></i>
                </button>
                <button id="addFrameBtn" class="bg-gray-200 text-gray-700 p-2 rounded-full">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
        </div>

        <!-- Barra lateral de herramientas -->
        <div id="toolSidebar" class="fixed left-0 top-0 w-20 h-full bg-gray-800 shadow-lg z-40 transform -translate-x-full transition-transform duration-300">
            <div class="flex flex-col items-center py-4 space-y-4 mt-20">
                <!-- Herramientas principales -->
                <button id="brushTool" class="sidebar-tool active" data-tool="brush">
                    <i class="fas fa-paint-brush text-xl"></i>
                </button>
                <button id="eraserTool" class="sidebar-tool" data-tool="eraser">
                    <i class="fas fa-eraser text-xl"></i>
                </button>
                <button id="paintBucketTool" class="sidebar-tool" data-tool="paintBucket">
                    <i class="fas fa-fill-drip text-xl"></i>
                </button>
                <button id="lassoTool" class="sidebar-tool" data-tool="lasso">
                    <i class="fas fa-draw-polygon text-xl"></i>
                </button>
                
                <!-- Divisor -->
                <div class="w-12 h-px bg-gray-600"></div>
                
                <!-- Control de grosor -->
                <div class="flex flex-col items-center space-y-2">
                    <i class="fas fa-circle text-xs text-gray-400"></i>
                    <input type="range" id="brushSize" min="1" max="50" value="5" 
                           class="w-12 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer transform -rotate-90 origin-center">
                    <span id="brushSizeDisplay" class="text-xs text-white">5</span>
                </div>
                
                <!-- Divisor -->
                <div class="w-12 h-px bg-gray-600"></div>
                
                <!-- Color actual -->
                <div class="flex flex-col items-center space-y-2">
                    <div id="currentColorDisplay" class="w-8 h-8 bg-black border-2 border-white rounded-full cursor-pointer"></div>
                    <input type="color" id="colorPicker" value="#000000" class="opacity-0 absolute pointer-events-none">
                </div>
                
                <!-- Paleta de colores -->
                <div class="grid grid-cols-2 gap-1 mt-2">
                    <div class="color-preset w-6 h-6 bg-black rounded cursor-pointer" data-color="#000000"></div>
                    <div class="color-preset w-6 h-6 bg-white border border-gray-400 rounded cursor-pointer" data-color="#ffffff"></div>
                    <div class="color-preset w-6 h-6 bg-red-500 rounded cursor-pointer" data-color="#ef4444"></div>
                    <div class="color-preset w-6 h-6 bg-blue-500 rounded cursor-pointer" data-color="#3b82f6"></div>
                    <div class="color-preset w-6 h-6 bg-green-500 rounded cursor-pointer" data-color="#10b981"></div>
                    <div class="color-preset w-6 h-6 bg-yellow-500 rounded cursor-pointer" data-color="#f59e0b"></div>
                    <div class="color-preset w-6 h-6 bg-purple-500 rounded cursor-pointer" data-color="#8b5cf6"></div>
                    <div class="color-preset w-6 h-6 bg-pink-500 rounded cursor-pointer" data-color="#ec4899"></div>
                </div>
            </div>
        </div>

        <!-- Área de dibujo y animación -->
        <div class="flex-grow flex justify-center items-center transition-all duration-300 px-2 pt-4 pb-4" id="drawingArea" style="width:100%; min-height: calc(100vh - 280px);">
            <div id="canvasWrapper" class="canvas-container bg-white rounded-lg shadow-inner">
                <canvas id="onionSkinCanvas"></canvas>
                <canvas id="drawingCanvas"></canvas>
                <canvas id="selectionCanvas"></canvas>
            </div>
        </div>

        <!-- Controles inferiores de diseño -->
        <div class="controls-bottom-bar flex flex-col">
            <div class="timeline-container w-full overflow-x-auto pb-2">
                <div id="framesContainer" class="flex items-center space-x-2 px-2 min-w-full">
                    <!-- Fotogramas se renderizarán aquí -->
                </div>
            </div>
            <div class="flex justify-around items-center py-4 border-t border-gray-200">
                <div class="flex flex-col items-center text-gray-400 cursor-pointer">
                    <i class="fas fa-music text-xl"></i>
                    <span class="text-xs mt-1">AUDIO</span>
                </div>
                <div class="flex flex-col items-center text-gray-400 cursor-pointer" id="undoBtn">
                    <i class="fas fa-undo text-xl"></i>
                    <span class="text-xs mt-1">DESHACER</span>
                </div>
                <div class="flex flex-col items-center text-gray-400 cursor-pointer" id="redoBtn">
                    <i class="fas fa-redo text-xl"></i>
                    <span class="text-xs mt-1">REHACER</span>
                </div>
                <div class="flex flex-col items-center text-gray-400 cursor-pointer">
                    <i class="fas fa-copy text-xl"></i>
                    <span class="text-xs mt-1">COPIAR</span>
                </div>
                <div class="flex flex-col items-center text-gray-400 cursor-pointer">
                    <i class="fas fa-paste text-xl"></i>
                    <span class="text-xs mt-1">PEGAR</span>
                </div>
                <div class="flex flex-col items-center text-gray-400 cursor-pointer" id="layerBtn">
                    <i class="fas fa-layer-group text-xl"></i>
                    <span class="text-xs mt-1">CAPA</span>
                </div>
            </div>
        </div>
        <!-- Panel de capas -->
        <div id="layerPanel" class="layer-panel">
            <div class="flex justify-between items-center mb-4">
                <h3 class="font-bold text-lg">Capas</h3>
                <button id="closeLayerPanelBtn" class="p-2 bg-gray-200 rounded-full"><i class="fas fa-times"></i></button>
            </div>
            <div id="layersList" class="flex flex-col-reverse">
                <!-- Capas se renderizarán aquí -->
            </div>
            <div class="flex justify-center mt-4 space-x-4">
                <button id="addLayerBtn" class="bg-red-500 text-white p-3 rounded-full font-semibold"><i class="fas fa-plus mr-2"></i>Añadir Capa</button>
            </div>
        </div>
    </div>

    <script>
        // -------------------------------------------------------
        // Hechos desde tu código original; aquí aplico fixes
        // - FIX 1: canvas CSS y posición para que el rect tenga tamaño
        // - FIX 2: inicializar tamaños de canvas con devicePixelRatio
        // - FIX 3: inicializar el lienzo al mostrar la pantalla de diseño
        // - FIX 4: manejar frames vacíos sin intentar dibujar imagen vacía
        // - FIX 5: permitir abrir proyecto al tocar la tarjeta (event listener)
        // -------------------------------------------------------

        // DOM Elements
        const homeScreen = document.getElementById('homeScreen');
        const designScreen = document.getElementById('designScreen');
        const addProjectBtn = document.getElementById('addProjectBtn');
        const newProjectModal = document.getElementById('newProjectModal');
        const cancelButton = document.getElementById('cancelButton');
        const createButton = document.getElementById('createButton');
        const closeBtn = document.getElementById('closeBtn');
        const proyectosContent = document.getElementById('proyectosContent');
        const peliculasContent = document.getElementById('peliculasContent');
        const proyectosTab = document.getElementById('proyectosTab');
        const peliculasTab = document.getElementById('peliculasTab');

        // Drawing and Animation Elements
        const canvasWrapper = document.getElementById('canvasWrapper') || document.querySelector('.canvas-container');
        const canvasContainer = canvasWrapper; // alias
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const onionSkinCanvas = document.getElementById('onionSkinCanvas');
        const onionSkinCtx = onionSkinCanvas.getContext('2d');
        const selectionCanvas = document.getElementById('selectionCanvas');
        const selectionCtx = selectionCanvas.getContext('2d');
        const toolSidebar = document.getElementById('toolSidebar');
        const toggleToolbarBtn = document.getElementById('toggleToolbarBtn');
        const drawingArea = document.getElementById('drawingArea');
        const brushToolBtn = document.getElementById('brushTool');
        const eraserToolBtn = document.getElementById('eraserTool');
        const paintBucketToolBtn = document.getElementById('paintBucketTool');
        const lassoToolBtn = document.getElementById('lassoTool');
        const colorPicker = document.getElementById('colorPicker');
        const currentColorDisplay = document.getElementById('currentColorDisplay');
        const brushSize = document.getElementById('brushSize');
        const brushSizeDisplay = document.getElementById('brushSizeDisplay');
        const colorPresets = document.querySelectorAll('.color-preset');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const framesContainer = document.getElementById('framesContainer');
        const addFrameBtn = document.getElementById('addFrameBtn');
        const playBtn = document.getElementById('playBtn');
        const onionSkinBtn = document.getElementById('onionSkinBtn');
        const sidebarTools = document.querySelectorAll('.sidebar-tool');
        const deleteSelectionBtn = document.getElementById('deleteSelectionBtn');
        const layerBtn = document.getElementById('layerBtn');
        const layerPanel = document.getElementById('layerPanel');
        const layersList = document.getElementById('layersList');
        const closeLayerPanelBtn = document.getElementById('closeLayerPanelBtn');
        const addLayerBtn = document.getElementById('addLayerBtn');
        const playIcon = '<i class="fas fa-play"></i> Reproducir';
        const pauseIcon = '<i class="fas fa-pause"></i> Pausar';

        // State variables
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let history = [];
        let historyIndex = -1;
        let frames = [];
        let activeFrame = 0;
        let animationInterval;
        let isPlaying = false;
        let onionSkinActive = true;
        let lassoPoints = [];
        let isMoving = false;
        let selectedImageData = null;
        let selectionStartOffset = {x: 0, y: 0};
        let fps = 12; // Nuevo estado para FPS

        // Layers state
        let layers = [];
        let activeLayer = 0;

        // Configuration
        let currentColor = '#000000';
        let currentSize = 5;
        let currentTool = 'brush';

        // Projects array (sin ejemplos)
        let projects = [];
        let currentProjectIndex = null;

        // -----------------------
        // --- FIX FUNCTIONS ---
        // -----------------------

        // Función simplificada para configurar el tamaño del canvas
        function setCanvasSizeToContainer() {
            const containerRect = canvasContainer.getBoundingClientRect();
            
            if (containerRect.width === 0 || containerRect.height === 0) {
                // Si el contenedor no tiene dimensiones, usar valores por defecto
                const canvasWidth = Math.min(window.innerWidth * 0.9, 600);
                const canvasHeight = canvasWidth / (16/9);
                
                [canvas, onionSkinCanvas, selectionCanvas].forEach(c => {
                    c.width = canvasWidth;
                    c.height = canvasHeight;
                });
            } else {
                // Usar las dimensiones del contenedor menos el padding
                const canvasWidth = containerRect.width - 8;
                const canvasHeight = containerRect.height - 8;

                [canvas, onionSkinCanvas, selectionCanvas].forEach(c => {
                    c.width = canvasWidth;
                    c.height = canvasHeight;
                });
            }

            // Reconfigurar contexto de dibujo
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentSize;
        }

        // Función mejorada para asegurar que el canvas esté listo
        function ensureCanvasReady() {
            // Configurar tamaño inmediatamente
            setCanvasSizeToContainer();
            
            // Esperar un frame para asegurar que el layout esté completo
            requestAnimationFrame(() => {
                // Verificar si necesitamos reconfigurar el tamaño
                if (!designScreen.classList.contains('hidden')) {
                    const rect = canvasContainer.getBoundingClientRect();
                    if (rect.width > 0 && rect.height > 0) {
                        setCanvasSizeToContainer();
                    }
                }
                
                // Redibujar contenido
                redrawCanvas();
            });
        }

        // Nueva función para redibujar el contenido del canvas
        function redrawCanvas() {
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // Limpiar todos los canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            onionSkinCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            selectionCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Redibujar frame actual si existe
            if (frames[activeFrame]) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                };
                img.src = frames[activeFrame];
            }

            // Redibujar onion skin si está activo
            if (onionSkinActive && activeFrame > 0 && frames[activeFrame - 1]) {
                const pimg = new Image();
                pimg.onload = () => {
                    onionSkinCtx.drawImage(pimg, 0, 0, canvasWidth, canvasHeight);
                };
                pimg.src = frames[activeFrame - 1];
            }
        }

        // -----------------------
        // Event Listeners for home screen
        function showHomeScreen() {
            homeScreen.classList.remove('hidden');
            designScreen.classList.add('hidden');
        }

        function showDesignScreen() {
            homeScreen.classList.add('hidden');
            designScreen.classList.remove('hidden');
            // Configurar canvas inmediatamente al mostrar la pantalla
            setTimeout(() => {
                ensureCanvasReady();
            }, 50); // Pequeño delay para asegurar que el DOM se haya actualizado
        }

        function renderProjects() {
            proyectosContent.innerHTML = '';
            projects.forEach((project, idx) => {
                const projectCard = document.createElement('div');
                projectCard.className = 'bg-white rounded-xl shadow-lg overflow-hidden relative cursor-pointer';
                projectCard.innerHTML = `
                    <div class="w-full h-48 bg-gray-200 flex items-center justify-center p-2">
                        <img src="${project.img}" alt="${project.name}" class="rounded-lg object-cover w-full h-full">
                    </div>
                    <div class="p-2 text-center">
                        <p class="text-sm font-semibold text-gray-700">${project.name}</p>
                        <p class="text-xs text-gray-500">${project.time} | ${project.fps}</p>
                    </div>
                    <div class="absolute top-2 right-2 flex items-center bg-black bg-opacity-50 text-white text-xs px-2 py-1 rounded-full">
                        <span class="mr-1">${project.time}</span>
                        <span class="mr-1">|</span>
                        <span>${project.fps}</span>
                    </div>
                `;
                // FIX: add click handler to open project (antes no se abría)
                projectCard.addEventListener('click', () => openProject(idx));
                proyectosContent.appendChild(projectCard);
            });
        }

        function setActiveTab(activeTab) {
            const tabs = [proyectosTab, peliculasTab];
            const contents = [proyectosContent, peliculasContent];
            
            tabs.forEach((tab, index) => {
                const indicator = tab.querySelector('.tab-indicator');
                if (tab === activeTab) {
                    tab.classList.add('text-red-500');
                    tab.classList.remove('text-gray-600');
                    indicator.classList.remove('w-0');
                    indicator.classList.add('w-2/3');
                    contents[index].classList.remove('hidden');
                } else {
                    tab.classList.add('text-gray-600');
                    tab.classList.remove('text-red-500');
                    indicator.classList.remove('w-2/3');
                    indicator.classList.add('w-0');
                    contents[index].classList.add('hidden');
                }
            });
        }

        proyectosTab.addEventListener('click', () => setActiveTab(proyectosTab));
        peliculasTab.addEventListener('click', () => setActiveTab(peliculasTab));
        
        addProjectBtn.addEventListener('click', () => {
            newProjectModal.classList.remove('hidden');
        });

        cancelButton.addEventListener('click', () => {
            newProjectModal.classList.add('hidden');
        });

        createButton.addEventListener('click', () => {
            const newProjectName = `nuevo proyecto ${projects.length + 1}`;
            projects.push({
                name: newProjectName,
                time: '00:00',
                fps: '12 fps',
                img: `https://placehold.co/200x200/cccccc/ffffff?text=${encodeURIComponent(newProjectName)}`,
                frames: [''] // FIX: create empty frame array so editor opens with a blank frame
            });
            saveToLocalStorage();
            renderProjects();
            newProjectModal.classList.add('hidden');
            // Abrir el nuevo proyecto
            openProject(projects.length - 1);
        });

        closeBtn.addEventListener('click', () => {
            showHomeScreen();
            // Pausar animación si se está reproduciendo
            if (isPlaying) {
                pauseAnimation();
            }
            // Guardar estado actual si hay proyecto abierto
            saveCurrentProject();
        });

        // Canvas Drawing Logic
        function initCanvas() {
            // Asegurar que el canvas tenga el tamaño correcto
            setCanvasSizeToContainer();

            // Estilos iniciales para el contexto de dibujo
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentSize;

            // Reinicializar el historial con el estado actual
            history = [canvas.toDataURL()];
            historyIndex = 0;
        }
        
        // Función para redimensionar los lienzos
        function resizeCanvas() {
            // FIX: redirige a setCanvasSizeToContainer para mantener consistencia
            setCanvasSizeToContainer();
        }

        // Manejador de redimensionamiento con debounce
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (!designScreen.classList.contains('hidden')) {
                    ensureCanvasReady();
                } else {
                    // Incluso si está oculto, actualizar para futuras aperturas
                    setCanvasSizeToContainer();
                }
            }, 100);
        });

        // Manejador para cambios de orientación en móviles
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                if (!designScreen.classList.contains('hidden')) {
                    ensureCanvasReady();
                } else {
                    setCanvasSizeToContainer();
                }
            }, 200); // Delay más largo para orientationchange
        });


        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY);
            if (clientX == null || clientY == null) return null;
            
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function draw(e) {
            if (!isDrawing) return;
            const coords = getCanvasCoordinates(e);
            if (!coords) return;
            
            const {x, y} = coords;

            if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
            } else if (currentTool === 'brush') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
            } else if (currentTool === 'lasso') {
                selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
                selectionCtx.strokeStyle = '#00f';
                selectionCtx.setLineDash([5, 5]);
                selectionCtx.lineWidth = 1;
                selectionCtx.beginPath();
                selectionCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                lassoPoints.forEach(p => selectionCtx.lineTo(p.x, p.y));
                selectionCtx.lineTo(x, y);
                selectionCtx.stroke();
                lassoPoints.push({x, y});
            }
            
            [lastX, lastY] = [x, y];
        }

        // Paint bucket fill function
        function floodFill(x, y, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            x = Math.floor(x);
            y = Math.floor(y);
            
            if (x < 0 || x >= width || y < 0 || y >= height) return;
            
            const index = (y * width + x) * 4;
            const targetColor = [data[index], data[index + 1], data[index + 2], data[index + 3]];
            
            // Convert hex color to RGB
            const hex = fillColor.replace('#', '');
            const newColor = [
                parseInt(hex.substr(0, 2), 16),
                parseInt(hex.substr(2, 2), 16),
                parseInt(hex.substr(4, 2), 16),
                255
            ];
            
            // Don't fill if colors are the same
            if (targetColor[0] === newColor[0] && targetColor[1] === newColor[1] && 
                targetColor[2] === newColor[2] && targetColor[3] === newColor[3]) {
                return;
            }
            
            const stack = [{x: x, y: y}];
            const visited = new Set();
            
            while (stack.length > 0) {
                const {x: currentX, y: currentY} = stack.pop();
                const key = `${currentX},${currentY}`;
                
                if (visited.has(key)) continue;
                if (currentX < 0 || currentX >= width || currentY < 0 || currentY >= height) continue;
                
                const currentIndex = (currentY * width + currentX) * 4;
                const currentColor = [data[currentIndex], data[currentIndex + 1], data[currentIndex + 2], data[currentIndex + 3]];
                
                if (currentColor[0] !== targetColor[0] || currentColor[1] !== targetColor[1] || 
                    currentColor[2] !== targetColor[2] || currentColor[3] !== targetColor[3]) {
                    continue;
                }
                
                visited.add(key);
                
                // Fill pixel
                data[currentIndex] = newColor[0];
                data[currentIndex + 1] = newColor[1];
                data[currentIndex + 2] = newColor[2];
                data[currentIndex + 3] = newColor[3];
                
                // Add neighbors to stack
                stack.push({x: currentX + 1, y: currentY});
                stack.push({x: currentX - 1, y: currentY});
                stack.push({x: currentX, y: currentY + 1});
                stack.push({x: currentX, y: currentY - 1});
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function startDrawing(e) {
            isDrawing = true;
            const coords = getCanvasCoordinates(e);
            if (!coords) return;
            
            const {x, y} = coords;
            [lastX, lastY] = [x, y];
            
            if (currentTool === 'lasso') {
                lassoPoints = [{x, y}];
                selectedImageData = null;
                deleteSelectionBtn.classList.add('hidden');
            } else {
                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }
                // Guardar el estado actual del lienzo para el historial
                history.push(canvas.toDataURL());
                historyIndex++;
            }
        }

        function stopDrawing() {
            isDrawing = false;
            
            if (currentTool === 'lasso' && lassoPoints.length > 2) {
                selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
                selectionCtx.setLineDash([]);
                
                // Create clipping path on a temporary canvas to extract selection
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCtx.beginPath();
                tempCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                lassoPoints.forEach(p => tempCtx.lineTo(p.x, p.y));
                tempCtx.closePath();
                tempCtx.clip();
                tempCtx.drawImage(canvas, 0, 0);

                // Get selected image data
                const minX = Math.min(...lassoPoints.map(p => p.x));
                const minY = Math.min(...lassoPoints.map(p => p.y));
                const maxX = Math.max(...lassoPoints.map(p => p.x));
                const maxY = Math.max(...lassoPoints.map(p => p.y));
                const width = Math.max(1, maxX - minX);
                const height = Math.max(1, maxY - minY);
                
                selectedImageData = tempCtx.getImageData(minX, minY, width, height);

                // Clear the selected area from the main canvas
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                lassoPoints.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
                
                // Draw a dashed path on selection canvas for user feedback
                selectionCtx.strokeStyle = '#00f';
                selectionCtx.setLineDash([5, 5]);
                selectionCtx.lineWidth = 1;
                selectionCtx.beginPath();
                selectionCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                lassoPoints.forEach(p => selectionCtx.lineTo(p.x, p.y));
                selectionCtx.closePath();
                selectionCtx.stroke();

                deleteSelectionBtn.classList.remove('hidden');
            } else {
                selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
                deleteSelectionBtn.classList.add('hidden');
            }

            // Guardar el estado del frame actual y actualizar miniatura
            saveFrame();
            updateFramePreviews();
            saveToLocalStorage();
        }

        function handleLassoMove(e) {
            const coords = getCanvasCoordinates(e);
            if (!coords) return;
            
            const {x, y} = coords;
            const dx = x - selectionStartOffset.x;
            const dy = y - selectionStartOffset.y;

            // Redibuja el lienzo sin la selección
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const backgroundDataURL = frames[activeFrame] || '';
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            const img = new Image();
            img.onload = () => {
                tempCtx.drawImage(img, 0, 0);
                tempCtx.globalCompositeOperation = 'destination-out';
                tempCtx.beginPath();
                tempCtx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                lassoPoints.forEach(p => tempCtx.lineTo(p.x, p.y));
                tempCtx.closePath();
                tempCtx.fill();
                tempCtx.globalCompositeOperation = 'source-over';
                
                ctx.drawImage(tempCanvas, 0, 0);
                
                if (selectedImageData) {
                    ctx.putImageData(selectedImageData, dx + Math.min(...lassoPoints.map(p => p.x)), dy + Math.min(...lassoPoints.map(p => p.y)));
                }
            };
            img.src = backgroundDataURL;
        }

        function handleLassoMoveEnd(e) {
            isMoving = false;
            // Guardar el estado final del movimiento
            saveFrame();
            updateFramePreviews();
            history.push(canvas.toDataURL());
            historyIndex++;
        }
        
        canvas.addEventListener('mousedown', (e) => {
            if (currentTool === 'paintBucket') {
                const coords = getCanvasCoordinates(e);
                if (coords) {
                    // Save state for undo
                    if (historyIndex < history.length - 1) {
                        history = history.slice(0, historyIndex + 1);
                    }
                    history.push(canvas.toDataURL());
                    historyIndex++;
                    
                    floodFill(coords.x, coords.y, currentColor);
                    saveFrame();
                    updateFramePreviews();
                }
                return;
            }
            
            if (currentTool === 'lasso' && selectedImageData) {
                isMoving = true;
                const coords = getCanvasCoordinates(e);
                if (coords) {
                    selectionStartOffset.x = coords.x;
                    selectionStartOffset.y = coords.y;
                }
            } else {
                startDrawing(e);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isMoving) {
                handleLassoMove(e);
            } else {
                draw(e);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isMoving) {
                handleLassoMoveEnd(e);
            } else {
                stopDrawing();
            }
        });
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (currentTool === 'paintBucket') {
                const coords = getCanvasCoordinates(e);
                if (coords) {
                    // Save state for undo
                    if (historyIndex < history.length - 1) {
                        history = history.slice(0, historyIndex + 1);
                    }
                    history.push(canvas.toDataURL());
                    historyIndex++;
                    
                    floodFill(coords.x, coords.y, currentColor);
                    saveFrame();
                    updateFramePreviews();
                }
                return;
            }
            
            if (currentTool === 'lasso' && selectedImageData) {
                isMoving = true;
                const coords = getCanvasCoordinates(e);
                if (coords) {
                    selectionStartOffset.x = coords.x;
                    selectionStartOffset.y = coords.y;
                }
            } else {
                startDrawing(e);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isMoving) {
                handleLassoMove(e);
            } else {
                draw(e);
            }
        });

        canvas.addEventListener('touchend', (e) => {
            if (isMoving) {
                handleLassoMoveEnd(e);
            } else {
                stopDrawing();
            }
        });

        // Tool Logic
        function selectTool(tool) {
            currentTool = tool;
            sidebarTools.forEach(btn => btn.classList.remove('active'));
            
            if (tool === 'brush') {
                brushToolBtn.classList.add('active');
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentSize;
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'eraser') {
                eraserToolBtn.classList.add('active');
                ctx.lineWidth = currentSize * 2;
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'paintBucket') {
                paintBucketToolBtn.classList.add('active');
                canvas.style.cursor = 'pointer';
            } else if (tool === 'lasso') {
                lassoToolBtn.classList.add('active');
                ctx.lineWidth = 1;
                canvas.style.cursor = 'crosshair';
            }
            selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            deleteSelectionBtn.classList.add('hidden');
        }

        // Sidebar toggle
        toggleToolbarBtn.addEventListener('click', () => {
            toolSidebar.classList.toggle('open');
            drawingArea.classList.toggle('sidebar-open');
        });

        // Tool selection
        sidebarTools.forEach(tool => {
            tool.addEventListener('click', () => {
                selectTool(tool.dataset.tool);
            });
        });

        // Color picker and presets
        currentColorDisplay.addEventListener('click', () => {
            colorPicker.click();
        });

        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            currentColorDisplay.style.backgroundColor = currentColor;
            colorPresets.forEach(preset => preset.classList.remove('active'));
            if (currentTool === 'brush') {
                ctx.strokeStyle = currentColor;
            }
        });

        colorPresets.forEach(preset => {
            preset.addEventListener('click', () => {
                const color = preset.dataset.color;
                currentColor = color;
                colorPicker.value = color;
                currentColorDisplay.style.backgroundColor = color;
                colorPresets.forEach(p => p.classList.remove('active'));
                preset.classList.add('active');
                if (currentTool === 'brush') {
                    ctx.strokeStyle = currentColor;
                }
            });
        });

        // Brush size control
        brushSize.addEventListener('input', (e) => {
            currentSize = e.target.value;
            brushSizeDisplay.textContent = currentSize;
            if (currentTool === 'brush') {
                ctx.lineWidth = currentSize;
            } else if (currentTool === 'eraser') {
                ctx.lineWidth = currentSize * 2;
            }
        });

        deleteSelectionBtn.addEventListener('click', () => {
            if (selectedImageData) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const backgroundDataURL = frames[activeFrame] || '';
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                    // Clear the selected area from the canvas
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.moveTo(lassoPoints[0].x, lassoPoints[0].y);
                    lassoPoints.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.closePath();
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                    saveFrame();
                    updateFramePreviews();
                    history.push(canvas.toDataURL());
                    historyIndex++;
                };
                img.src = backgroundDataURL;
                
                selectedImageData = null;
                deleteSelectionBtn.classList.add('hidden');
                selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            }
        });

        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            if (currentTool === 'brush') {
                ctx.strokeStyle = currentColor;
            }
        });

        brushSize.addEventListener('input', (e) => {
            currentSize = e.target.value;
            if (currentTool === 'brush') {
                ctx.lineWidth = currentSize;
            } else if (currentTool === 'eraser') {
                ctx.lineWidth = currentSize * 2;
            }
        });

        // Undo/Redo Logic
        undoBtn.addEventListener('click', () => {
            if (historyIndex > 0) {
                historyIndex--;
                const tempImage = new Image();
                tempImage.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(tempImage, 0, 0);
                    saveFrame();
                    updateFramePreviews();
                };
                tempImage.src = history[historyIndex];
            }
        });

        redoBtn.addEventListener('click', () => {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                const tempImage = new Image();
                tempImage.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(tempImage, 0, 0);
                    saveFrame();
                    updateFramePreviews();
                };
                tempImage.src = history[historyIndex];
            }
        });
        
        // Animation Logic
        function saveFrame() {
            // FIX: guardamos frame sólo si hay proyecto abierto; si no, lo guardamos localmente en frames
            frames[activeFrame] = canvas.toDataURL();
            if (currentProjectIndex !== null) {
                projects[currentProjectIndex].frames = frames.slice();
            }
            // (Opcional) podrías persistir toda la lista de proyectos en localStorage aquí
        }

        function loadFrame(frameIndex) {
            // Guardar el fotograma actual antes de cambiar
            saveFrame();
            activeFrame = frameIndex;
            
            // Limpiar
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            onionSkinCtx.clearRect(0, 0, onionSkinCanvas.width, onionSkinCanvas.height);
            
            // Cargar capa anterior como 'capa cebolla' si está activa y no es el primer fotograma
            if (onionSkinActive && frameIndex > 0 && frames[frameIndex - 1]) {
                const prevImg = new Image();
                prevImg.onload = () => {
                    onionSkinCtx.clearRect(0, 0, onionSkinCanvas.width, onionSkinCanvas.height);
                    onionSkinCtx.drawImage(prevImg, 0, 0, canvas.width, canvas.height);
                };
                prevImg.src = frames[frameIndex - 1];
            } else {
                onionSkinCtx.clearRect(0, 0, onionSkinCanvas.width, onionSkinCanvas.height);
            }

            // Cargar fotograma actual
            if (frames[frameIndex]) {
                const currentImg = new Image();
                currentImg.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(currentImg, 0, 0, canvas.width, canvas.height);
                    // Limpiar el historial y guardar el estado inicial del nuevo frame
                    history = [canvas.toDataURL()];
                    historyIndex = 0;
                };
                currentImg.src = frames[frameIndex];
            } else {
                // frame vacío -> lienzo limpio
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                history = [canvas.toDataURL()];
                historyIndex = 0;
            }

            updateFramePreviews();
        }

        function addFrame() {
            saveFrame();
            // Si el fotograma activo tiene contenido, crea una copia en el siguiente fotograma
            const nextFrameData = frames[activeFrame] || null;
            frames.splice(activeFrame + 1, 0, nextFrameData);
            activeFrame++;
            loadFrame(activeFrame);
            updateFramePreviews();
            saveToLocalStorage();
        }

        function updateFramePreviews() {
            const existingFrames = framesContainer.querySelectorAll('.frame-preview');
            
            // Si la cantidad de frames cambió, recrear todo
            if (existingFrames.length !== frames.length) {
                framesContainer.innerHTML = '';
                frames.forEach((frameData, index) => {
                    createFramePreview(index, frameData);
                });
            } else {
                // Solo actualizar las miniaturas que necesiten actualización
                frames.forEach((frameData, index) => {
                    const frameEl = existingFrames[index];
                    if (frameEl) {
                        // Actualizar imagen de fondo
                        frameEl.style.backgroundImage = frameData ? `url(${frameData})` : '';
                        // Actualizar clase activa
                        frameEl.className = `frame-preview bg-gray-200 flex-shrink-0 relative ${index === activeFrame ? 'active' : ''}`;
                    }
                });
            }
            
            // Desplazar la línea de tiempo para mostrar el fotograma activo
            const activeFrameEl = framesContainer.querySelector('.frame-preview.active');
            if (activeFrameEl) {
                framesContainer.scrollLeft = activeFrameEl.offsetLeft - (framesContainer.offsetWidth / 2) + (activeFrameEl.offsetWidth / 2);
            }
        }

        function createFramePreview(index, frameData) {
            const frameEl = document.createElement('div');
            frameEl.className = `frame-preview bg-gray-200 flex-shrink-0 relative ${index === activeFrame ? 'active' : ''}`;
            frameEl.style.backgroundImage = frameData ? `url(${frameData})` : '';
            frameEl.style.backgroundSize = 'contain';
            frameEl.style.backgroundPosition = 'center';
            frameEl.style.backgroundColor = '#fff';
            frameEl.draggable = true;
            frameEl.dataset.frameIndex = index;
            frameEl.innerHTML = `<span class="frame-number">${index + 1}</span>`;
            
            // Click event for frame selection
            frameEl.addEventListener('click', (e) => {
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                if (isPlaying) {
                    pauseAnimation();
                }
                loadFrame(index);
            });

            // Context menu on long press/right click
            let longPressTimer;
            let isLongPress = false;

            frameEl.addEventListener('mousedown', (e) => {
                if (e.button === 2) { // Right click
                    e.preventDefault();
                    showFrameContextMenu(e, index);
                    return;
                }
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    showFrameContextMenu(e, index);
                }, 500);
            });

            frameEl.addEventListener('mouseup', () => {
                clearTimeout(longPressTimer);
                setTimeout(() => { isLongPress = false; }, 100);
            });

            frameEl.addEventListener('click', (e) => {
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
            });

            frameEl.addEventListener('touchstart', (e) => {
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    e.preventDefault();
                    showFrameContextMenu(e.touches[0], index);
                }, 500);
            });

            frameEl.addEventListener('touchend', (e) => {
                clearTimeout(longPressTimer);
                if (!isLongPress) {
                    if (isPlaying) {
                        pauseAnimation();
                    }
                    loadFrame(index);
                }
                setTimeout(() => { isLongPress = false; }, 100);
            });

            // Drag and drop events
            frameEl.addEventListener('dragstart', (e) => {
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', index);
                frameEl.classList.add('dragging');
            });

            frameEl.addEventListener('dragend', () => {
                frameEl.classList.remove('dragging');
                document.querySelectorAll('.frame-preview').forEach(el => {
                    el.classList.remove('drag-over');
                });
            });

            frameEl.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });

            frameEl.addEventListener('dragenter', (e) => {
                e.preventDefault();
                frameEl.classList.add('drag-over');
            });

            frameEl.addEventListener('dragleave', (e) => {
                frameEl.classList.remove('drag-over');
            });

            frameEl.addEventListener('drop', (e) => {
                e.preventDefault();
                frameEl.classList.remove('drag-over');
                const draggedIndex = parseInt(e.dataTransfer.getData('text/plain'));
                const targetIndex = index;
                
                if (draggedIndex !== targetIndex) {
                    reorderFrames(draggedIndex, targetIndex);
                }
            });

            framesContainer.appendChild(frameEl);
        }
        
        addFrameBtn.addEventListener('click', () => {
            if (isPlaying) {
                pauseAnimation();
            }
            addFrame();
        });

        function playAnimation() {
            if (isPlaying) return;
            if (frames.length === 0) return;
            isPlaying = true;
            playBtn.innerHTML = pauseIcon;
            let currentFrameIndex = activeFrame;
            animationInterval = setInterval(() => {
                currentFrameIndex = (currentFrameIndex + 1) % frames.length;
                loadFrame(currentFrameIndex);
            }, 1000 / fps); // Usa la variable fps
        }

        function pauseAnimation() {
            isPlaying = false;
            playBtn.innerHTML = playIcon;
            clearInterval(animationInterval);
        }

        playBtn.addEventListener('click', () => {
            if (isPlaying) {
                pauseAnimation();
            } else {
                playAnimation();
            }
        });

        // Onion Skin Logic
        onionSkinBtn.addEventListener('click', () => {
            onionSkinActive = !onionSkinActive;
            onionSkinBtn.classList.toggle('active', onionSkinActive);
            loadFrame(activeFrame);
        });
        onionSkinBtn.classList.add('active'); // Mantiene el botón de la capa cebolla activo

        // Layer Panel Logic
        layerBtn.addEventListener('click', () => {
            layerPanel.classList.add('active');
            renderLayers();
        });

        closeLayerPanelBtn.addEventListener('click', () => {
            layerPanel.classList.remove('active');
        });

        addLayerBtn.addEventListener('click', () => {
            layers.push({ id: Date.now(), visible: true, data: [] });
            renderLayers();
        });

        function renderLayers() {
            layersList.innerHTML = '';
            layers.forEach((layer, index) => {
                const layerEl = document.createElement('div');
                layerEl.className = 'layer-item';
                layerEl.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <i class="fas fa-grip-vertical text-gray-400 drag-handle"></i>
                        <span>Capa ${index + 1}</span>
                    </div>
                    <button class="text-gray-500 hover:text-red-500" onclick="toggleLayer(${index})">
                        <i class="fas fa-eye${layer.visible ? '' : '-slash'}"></i>
                    </button>
                `;
                layerEl.dataset.index = index;
                layersList.appendChild(layerEl);

                // Swipe logic
                let startX;
                layerEl.addEventListener('touchstart', (e) => {
                    startX = e.touches[0].clientX;
                });

                layerEl.addEventListener('touchmove', (e) => {
                    let currentX = e.touches[0].clientX;
                    let diff = startX - currentX;
                    if (diff > 50) {
                        layerEl.classList.add('swiped');
                    } else if (diff < -50) {
                        layerEl.classList.remove('swiped');
                    }
                });
            });
            setupDragAndDrop();
        }

        function setupDragAndDrop() {
            const list = document.getElementById('layersList');
            let draggingEl;

            list.addEventListener('dragstart', (e) => {
                draggingEl = e.target.closest('.layer-item');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', draggingEl.dataset.index);
            });

            list.addEventListener('dragover', (e) => {
                e.preventDefault();
                const targetEl = e.target.closest('.layer-item');
                if (targetEl && targetEl !== draggingEl) {
                    const rect = targetEl.getBoundingClientRect();
                    const next = (e.clientY - rect.top) / rect.height > 0.5;
                    list.insertBefore(draggingEl, next ? targetEl.nextSibling : targetEl);
                }
            });

            list.addEventListener('drop', (e) => {
                e.preventDefault();
                const newOrder = Array.from(list.children).map(el => layers[el.dataset.index]);
                layers = newOrder;
                renderLayers();
            });
        }
        
        function toggleLayer(index) {
            layers[index].visible = !layers[index].visible;
            renderLayers();
            updateCanvasLayers();
        }

        function updateCanvasLayers() {
            // Placeholder
            // Aquí podrías volver a renderizar todas las capas visibles en el canvas principal
            console.log("Updating canvas layers...");
        }

        // Abrir proyecto existente
        function openProject(index) {
            currentProjectIndex = index;
            const project = projects[index];
            frames = project.frames && project.frames.length ? project.frames.slice() : [''];
            activeFrame = 0;
            
            // Configurar canvas antes de mostrar la pantalla
            setCanvasSizeToContainer();
            showDesignScreen();
            
            // Inicializar canvas después de mostrar la pantalla
            setTimeout(() => {
                initCanvas();
                loadFrame(activeFrame);
                updateFramePreviews();
            }, 100);
        }

        // Context menu functionality
        function showFrameContextMenu(event, frameIndex) {
            // Remove any existing context menu
            const existingMenu = document.querySelector('.frame-context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }

            const menu = document.createElement('div');
            menu.className = 'frame-context-menu';
            menu.innerHTML = `
                <button onclick="duplicateFrame(${frameIndex}); event.stopPropagation();">
                    <i class="fas fa-copy mr-2"></i>Duplicar
                </button>
                <button onclick="deleteFrame(${frameIndex}); event.stopPropagation();" class="delete" ${frames.length <= 1 ? 'disabled style="opacity: 0.5; pointer-events: none;"' : ''}>
                    <i class="fas fa-trash mr-2"></i>Eliminar
                </button>
            `;

            const frameEl = document.querySelector(`[data-frame-index="${frameIndex}"]`);
            if (frameEl) {
                frameEl.appendChild(menu);
                
                // Close menu when clicking elsewhere
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu(e) {
                        if (!menu.contains(e.target)) {
                            menu.remove();
                            document.removeEventListener('click', closeMenu);
                        }
                    });
                }, 100);
            }
        }

        function duplicateFrame(frameIndex) {
            if (isPlaying) {
                pauseAnimation();
            }
            
            saveFrame(); // Save current frame
            const frameData = frames[frameIndex] || '';
            frames.splice(frameIndex + 1, 0, frameData);
            
            // Update active frame if needed
            if (frameIndex <= activeFrame) {
                activeFrame++;
            }
            
            updateFramePreviews();
            saveToLocalStorage();
            
            // Remove context menu
            const menu = document.querySelector('.frame-context-menu');
            if (menu) menu.remove();
        }

        function deleteFrame(frameIndex) {
            if (frames.length <= 1) return; // Don't delete if it's the only frame
            
            if (isPlaying) {
                pauseAnimation();
            }
            
            frames.splice(frameIndex, 1);
            
            // Adjust active frame
            if (frameIndex <= activeFrame) {
                activeFrame = Math.max(0, activeFrame - 1);
            }
            if (activeFrame >= frames.length) {
                activeFrame = frames.length - 1;
            }
            
            loadFrame(activeFrame);
            updateFramePreviews();
            saveToLocalStorage();
            
            // Remove context menu
            const menu = document.querySelector('.frame-context-menu');
            if (menu) menu.remove();
        }

        function reorderFrames(fromIndex, toIndex) {
            if (fromIndex === toIndex) return;
            
            if (isPlaying) {
                pauseAnimation();
            }
            
            const draggedFrame = frames.splice(fromIndex, 1)[0];
            frames.splice(toIndex, 0, draggedFrame);
            
            // Update active frame index
            if (fromIndex === activeFrame) {
                activeFrame = toIndex;
            } else if (fromIndex < activeFrame && toIndex >= activeFrame) {
                activeFrame--;
            } else if (fromIndex > activeFrame && toIndex <= activeFrame) {
                activeFrame++;
            }
            
            updateFramePreviews();
            saveToLocalStorage();
        }

        // LocalStorage functionality
        function saveToLocalStorage() {
            saveCurrentProject();
            localStorage.setItem('flipaclip_projects', JSON.stringify(projects));
        }

        function loadFromLocalStorage() {
            const savedProjects = localStorage.getItem('flipaclip_projects');
            if (savedProjects) {
                try {
                    projects = JSON.parse(savedProjects);
                } catch (e) {
                    console.error('Error loading projects from localStorage:', e);
                }
            }
        }

        // Guardar proyecto en array
        function saveCurrentProject() {
            if (currentProjectIndex === null) return;
            projects[currentProjectIndex].frames = frames.slice();
            
            // Update project thumbnail with first frame
            if (frames.length > 0 && frames[0]) {
                projects[currentProjectIndex].img = frames[0];
            }
            
            // Update time based on frame count and fps
            const totalSeconds = Math.ceil(frames.length / fps);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            projects[currentProjectIndex].time = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Initial rendering
        window.onload = () => {
            loadFromLocalStorage();
            renderProjects();
            setActiveTab(proyectosTab);
            // NOTA: no llamar resizeCanvas() aquí porque el designScreen suele estar oculto;
            // initCanvas / setCanvasSizeToContainer se llaman cuando se abre el editor (openProject / showDesignScreen)
        };
    </script>
</body>
</html>
